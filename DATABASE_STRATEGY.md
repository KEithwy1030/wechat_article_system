# 数据库策略分析

## 📊 当前数据库使用情况

### SQLite 配置
- **主数据库**: `system.db` (200KB) - 赛程、赛果数据
- **统计数据库**: `data/prediction_stats.db` (28KB)
- **预测数据库**: `data/quick_predictions.db` (16KB)
- **显示数据库**: `data/schedule_display.db` (32KB)

### 并发配置
- **Gunicorn**: 2 workers × 4 threads = 8 并发请求
- **SQLite WAL 模式**: 已启用（支持并发读取，写入有锁）
- **超时设置**: `busy_timeout=30000` (30秒), `timeout=30`
- **队列管理**: 已实现任务队列限制并发写入

## 🤔 是否需要 MySQL？

### ❌ **当前不需要 MySQL 的原因**

1. **单实例部署**
   - Zeabur 通常单实例运行
   - SQLite 在单实例下性能足够

2. **数据量小**
   - 总数据量 < 300KB
   - SQLite 可支持到几 GB

3. **写入频率低**
   - 主要是定时任务（赛程更新、赛果更新）
   - 用户操作写入较少
   - 已有队列管理避免并发冲突

4. **已有优化**
   - WAL 模式提高并发性能
   - 多数据库文件分散写入压力
   - 超时和重试机制

5. **成本考虑**
   - MySQL 需要额外服务（增加成本）
   - SQLite 零成本、零配置

### ✅ **未来可能需要 MySQL 的情况**

1. **多实例部署**
   - 需要水平扩展
   - SQLite 不支持多实例共享

2. **高并发写入**
   - 用户量大幅增长
   - 实时写入需求增加

3. **数据持久化要求**
   - 需要自动备份
   - 需要数据恢复功能

4. **数据量增长**
   - 数据量超过几 GB
   - 需要复杂查询优化

## 🎯 推荐方案

### 方案 1：继续使用 SQLite + 持久化存储（推荐）

**优点**：
- ✅ 零成本、零配置
- ✅ 性能足够当前需求
- ✅ 简单易维护

**关键步骤**：
1. **在 Zeabur 配置持久化存储**
   - 进入项目设置 → Storage/Volumes
   - 创建持久化卷挂载到 `/app` 和 `/app/data`
   - 确保数据在容器重启后不丢失

2. **定期备份**
   - 使用 Zeabur 的备份功能
   - 或通过脚本定期导出数据

**配置示例**（Zeabur Volume）：
```
/app → 持久化卷（存储 system.db）
/app/data → 持久化卷（存储其他数据库）
```

### 方案 2：迁移到 MySQL（未来考虑）

**何时迁移**：
- 数据量 > 1GB
- 需要多实例部署
- 写入并发 > 50/秒
- 需要高级数据库功能

**迁移成本**：
- 需要修改代码（SQL 语法差异）
- 需要配置 MySQL 服务
- 需要数据迁移脚本
- 增加运维复杂度

## 📝 当前最佳实践

### 1. 确保数据持久化

在 Zeabur 中：
- ✅ 配置持久化存储卷
- ✅ 挂载到 `/app` 和 `/app/data`
- ✅ 定期检查数据是否保存

### 2. 监控数据库性能

关注指标：
- 数据库文件大小
- 写入延迟
- 并发冲突日志

### 3. 准备迁移方案（可选）

如果未来需要，可以：
- 创建数据库抽象层
- 支持 SQLite 和 MySQL 切换
- 准备数据迁移脚本

## 🔍 验证当前配置

检查 SQLite 是否正常工作：
```bash
# 在 Zeabur Shell 中
cd /app
sqlite3 system.db "PRAGMA journal_mode;"
# 应该返回: wal

sqlite3 system.db "SELECT COUNT(*) FROM lottery_matches;"
# 检查数据是否正常
```

## 💡 结论

**当前建议**：**不需要 MySQL**

1. SQLite 完全满足当前需求
2. 配置持久化存储即可
3. 未来需要时再迁移（成本低）

**关键点**：确保 Zeabur 使用持久化存储，避免数据丢失。

